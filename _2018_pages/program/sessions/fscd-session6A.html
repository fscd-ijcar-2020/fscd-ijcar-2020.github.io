---
permalink: /program/sessions/fscd-session6A
published: true
---

<div class="cd-schedule-modal__event-info">
	<div>
        <p><strong>Session 6A</strong></p>
        <p>Chair: Cynthia Kop</p>

<ul style="list-style-position: outside; list-style: square;">
<li>
17:00: <strong>Besik Dundua, Temur Kutsia, Mircea Marin, Cleopatra Pau.</strong>
<it>Constraint Solving over Multiple Similarity Relations.</it>

            &nbsp;&nbsp;&nbsp;
            <a data-toggle="collapse"
                href="#collapseAbstract1" role="button"
                style="font-size: var(--text-xsm);"
                aria-expanded="false" aria-controls="collapseAbstract1">
                See abstract
            </a>...
            <div class="collapse" id="collapseAbstract1">
                <div class="card card-body" style="padding-left:20px">
        ABSTRACT. Similarity relations are reflexive, symmetric, and transitive fuzzy relations. They help to make approximate inferences, replacing the notion of equality. Similarity-based unification has been quite intensively investigated, as a core computational method for approximate reasoning and declarative programming. In this paper we make a step forward, considering solving constraints over several similarity relations, instead of a single one. Multiple similarities pose challenges to constraint solving, since we can not rely on the transitivity property anymore. Existing methods for unification with fuzzy proximity relations (reflexive, symmetric, non-transitive relations) do not provide a solution that would adequately reflect particularities of dealing with multiple similarities simultaneously. To address this problem, we develop a constraint solving algorithm for multiple similarity relations, prove its termination, soundness, and completeness properties, and discuss applications.
                </div>
            </div>
        </li>
<li>
17:30: <strong>Claude Stolze, Luigi Liquori.</strong>
<it>A Type Checker for a Logical Framework with Union and Intersection Types - System description.</it>

            &nbsp;&nbsp;&nbsp;
            <a data-toggle="collapse"
                href="#collapseAbstract2" role="button"
                style="font-size: var(--text-xsm);"
                aria-expanded="false" aria-controls="collapseAbstract2">
                See abstract
            </a>...
            <div class="collapse" id="collapseAbstract2">
                <div class="card card-body" style="padding-left:20px">
        ABSTRACT. We present the syntax, semantics, and typing rules of Bull, a prototype theorem prover based on the ∆-framework, i.e. a fully-typed lambda-calculus decorated with union and intersection types, as described in previous papers by the authors. Bull also implements a subtyping algorithm for the Type Theory Ξ of Barbanera-Dezani-de'Liguoro. Bull has a command-line interface where the user can declare axioms, terms, and perform computations and some basic terminal-style features like error pretty-printing, subexpressions highlighting, and file loading. Moreover, it can typecheck a proof or normalize it. These terms can be incomplete, therefore the typechecking algorithm uses unification to try to construct the missing subterms. Bull uses the syntax of Berardi’s Pure Type Systems to improve the compactness and the modularity of the kernel. Abstract and concrete syntax are mostly aligned and similar to the concrete syntax of Coq. Bull uses a higher-order unification algorithm for terms, while typechecking and partial type inference are done by a bidirectional refinement algorithm, similar to the one found in Matita and Beluga. The refinement can be split into two parts: the essence refinement and the typing refinement. Binders are implemented using commonly-used de Bruijn indices. We have defined a concrete language syntax that will allow user to write ∆-terms. We have defined the reduction rules and an evaluator. We have implemented from scratch a refiner which does partial typechecking and type reconstruction. We have experimented Bull with classical examples of the intersection and union literature, such as the ones formalized by Pfenning with his Refinement Types in LF. We hope that this research vein could be useful to experiment, in a proof theoretical setting, forms of polymorphism alternatives to Girard's parametric one.
                </div>
            </div>
        </li>
<li>
18:00: <strong>Petar Vukmirović, Alexander Bentkamp, Visa Nummelin.</strong>
<it>Efficient Full Higher-Order Unification *** Best paper by junior researchers.</it>

            &nbsp;&nbsp;&nbsp;
            <a data-toggle="collapse"
                href="#collapseAbstract3" role="button"
                style="font-size: var(--text-xsm);"
                aria-expanded="false" aria-controls="collapseAbstract3">
                See abstract
            </a>...
            <div class="collapse" id="collapseAbstract3">
                <div class="card card-body" style="padding-left:20px">
        ABSTRACT. We developed a procedure to enumerate complete sets of higher-order unifiers based on work by Jensen and Pietrzykowski. Our procedure removes many redundant unifiers by carefully restricting the search space and tightly integrating decision procedures for fragments that admit a finite complete set of unifiers. We identify a new such fragment and describe an algorithm for computing its unifiers. Our unification procedure is implemented in the Zipperposition theorem prover. Experimental evaluation shows a clear advantage over Jensen and Pietrzykowski's procedure.
                </div>
            </div>
        </li>
</ul>

    </div>
</div>
