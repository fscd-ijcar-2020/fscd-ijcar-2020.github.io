---
permalink: /program/sessions/fscd-session6B
published: true
---

<div class="cd-schedule-modal__event-info">
	<div>
        <p><strong>Session 6B</strong></p>
        <p>Chair: Tarmo Uustalu</p>

<ul style="list-style-position: outside; list-style: square;">
<li>
17:00: <strong>Cyril Cohen, Kazuhiko Sakaguchi, Enrico Tassi.</strong>
<it>Hierarchy Builder: algebraic hierarchies made easy in Coq with Elpi - System description.</it>

            &nbsp;&nbsp;&nbsp;
            <a data-toggle="collapse"
                href="#collapseAbstract1" role="button"
                style="font-size: var(--text-xsm);"
                aria-expanded="false" aria-controls="collapseAbstract1">
                See abstract
            </a>...
            <div class="collapse" id="collapseAbstract1">
                <div class="card card-body" style="padding-left:20px">
        ABSTRACT. It is nowadays customary to organize libraries of machine checked proofs around hierarchies of algebraic structures. One influential example is the Mathematical Components library on top of which the long and intricate proof of the Odd Order Theorem could be fully formalized.<br/>
Still, building algebraic hierarchies in a proof assistant such as Coq requires a lot of manual labor and often a deep expertise in the internals of the prover. Moreover, according to our experience, making a hierarchy evolve without causing breakage in client code is equally tricky: even a simple refactoring such as splitting a structure into two simpler ones is hard to get right. <br/>
In this paper we describe HB, a high level language to build hierarchies of algebraic structures and to make these hierarchies evolve without breaking user code. The key concepts are the ones of factory, builder and abbreviation that let the hierarchy developer describe an actual interface for their library. Behind that interface the developer can provide appropriate code to ensure backward compatibility. We implement the HB language in the hierarchy-builder addon for the Coq system using the Elpi extension language.
                </div>
            </div>
        </li>
<li>
17:30: <strong>Andr√© Hirschowitz, Tom Hirschowitz, Ambroise Lafont.</strong>
<it>Modules over monads and operational semantics.</it>

            &nbsp;&nbsp;&nbsp;
            <a data-toggle="collapse"
                href="#collapseAbstract2" role="button"
                style="font-size: var(--text-xsm);"
                aria-expanded="false" aria-controls="collapseAbstract2">
                See abstract
            </a>...
            <div class="collapse" id="collapseAbstract2">
                <div class="card card-body" style="padding-left:20px">
        ABSTRACT. This paper is a contribution to the search for efficient and
high-level mathematical tools to specify and reason about (abstract)
programming languages or calculi.  Generalising the reduction monads
of Ahrens et al., we introduce operational monads, thus covering new
applications such as the pi-calculus, Positive GSOS specifications,
and the big-step, simply-typed, call-by-value
lambda-calculus. Finally, we design a notion of signature for
operational monads that covers all our examples.
                </div>
            </div>
        </li>
</ul>

    </div>
</div>
